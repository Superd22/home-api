{"ast":null,"code":"import { OAuthErrorEvent } from 'angular-oauth2-oidc';\nimport { BehaviorSubject, combineLatest } from 'rxjs';\nimport { filter, map } from 'rxjs/operators';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"angular-oauth2-oidc\";\nimport * as i2 from \"@angular/router\";\nexport class AuthService {\n  constructor(oauthService, router) {\n    this.oauthService = oauthService;\n    this.router = router;\n    this.isAuthenticatedSubject$ = new BehaviorSubject(false);\n    this.isAuthenticated$ = this.isAuthenticatedSubject$.asObservable();\n    this.isDoneLoadingSubject$ = new BehaviorSubject(false);\n    this.isDoneLoading$ = this.isDoneLoadingSubject$.asObservable();\n    /**\n     * Publishes `true` if and only if (a) all the asynchronous initial\n     * login calls have completed or errorred, and (b) the user ended up\n     * being authenticated.\n     *\n     * In essence, it combines:\n     *\n     * - the latest known state of whether the user is authorized\n     * - whether the ajax calls for initial log in have all been done\n     */\n    this.canActivateProtectedRoutes$ = combineLatest([this.isAuthenticated$, this.isDoneLoading$]).pipe(map(values => values.every(b => b)));\n    // Useful for debugging:\n    this.oauthService.events.subscribe(event => {\n      if (event instanceof OAuthErrorEvent) {\n        console.error('OAuthErrorEvent Object:', event);\n      } else {\n        console.warn('OAuthEvent Object:', event);\n      }\n    });\n    // This is tricky, as it might cause race conditions (where access_token is set in another\n    // tab before everything is said and done there.\n    // TODO: Improve this setup. See: https://github.com/jeroenheijmans/sample-angular-oauth2-oidc-with-auth-guards/issues/2\n    window.addEventListener('storage', event => {\n      // The `key` is `null` if the event was caused by `.clear()`\n      if (event.key !== 'access_token' && event.key !== null) {\n        return;\n      }\n      console.warn('Noticed changes to access_token (most likely from another tab), updating isAuthenticated');\n      this.isAuthenticatedSubject$.next(this.oauthService.hasValidAccessToken());\n      if (!this.oauthService.hasValidAccessToken()) {\n        this.navigateToLoginPage();\n      }\n    });\n    this.oauthService.events.subscribe(_ => {\n      this.isAuthenticatedSubject$.next(this.oauthService.hasValidAccessToken());\n    });\n    this.isAuthenticatedSubject$.next(this.oauthService.hasValidAccessToken());\n    this.oauthService.events.pipe(filter(e => ['token_received'].includes(e.type))).subscribe(e => this.oauthService.loadUserProfile());\n    this.oauthService.events.pipe(filter(e => ['session_terminated', 'session_error'].includes(e.type))).subscribe(e => this.navigateToLoginPage());\n    // this.oauthService.setup();\n  }\n\n  navigateToLoginPage() {\n    // TODO: Remember current URL\n    this.router.navigateByUrl('/should-login');\n  }\n  runInitialLoginSequence() {\n    if (location.hash) {\n      console.log('Encountered hash fragment, plotting as table...');\n      console.table(location.hash.substr(1).split('&').map(kvp => kvp.split('=')));\n    }\n    // 0. LOAD CONFIG:\n    // First we have to check to see how the IdServer is\n    // currently configured:\n    return this.oauthService.loadDiscoveryDocument().then(() => {\n      this.oauthService.initCodeFlow();\n    });\n  }\n  login(targetUrl) {\n    // Note: before version 9.1.0 of the library you needed to\n    // call encodeURIComponent on the argument to the method.\n    this.oauthService.initLoginFlow(targetUrl || this.router.url);\n  }\n  logout() {\n    this.oauthService.logOut();\n  }\n  refresh() {\n    this.oauthService.silentRefresh();\n  }\n  hasValidToken() {\n    return this.oauthService.hasValidAccessToken();\n  }\n  // These normally won't be exposed from a service like this, but\n  // for debugging it makes sense.\n  get accessToken() {\n    return this.oauthService.getAccessToken();\n  }\n  get refreshToken() {\n    return this.oauthService.getRefreshToken();\n  }\n  get identityClaims() {\n    return this.oauthService.getIdentityClaims();\n  }\n  get idToken() {\n    return this.oauthService.getIdToken();\n  }\n  get logoutUrl() {\n    return this.oauthService.logoutUrl;\n  }\n  static #_ = this.ɵfac = function AuthService_Factory(t) {\n    return new (t || AuthService)(i0.ɵɵinject(i1.OAuthService), i0.ɵɵinject(i2.Router));\n  };\n  static #_2 = this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: AuthService,\n    factory: AuthService.ɵfac,\n    providedIn: 'root'\n  });\n}","map":{"version":3,"mappings":"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","names":["OAuthErrorEvent","BehaviorSubject","combineLatest","filter","map","AuthService","constructor","oauthService","router","isAuthenticatedSubject$","asObservable","isDoneLoadingSubject$","isAuthenticated$","isDoneLoading$","pipe","values","every","b","events","subscribe","event","console","error","warn","window","addEventListener","key","next","hasValidAccessToken","navigateToLoginPage","_","e","includes","type","loadUserProfile","navigateByUrl","runInitialLoginSequence","location","hash","log","table","substr","split","kvp","loadDiscoveryDocument","then","initCodeFlow","login","targetUrl","initLoginFlow","url","logout","logOut","refresh","silentRefresh","hasValidToken","accessToken","getAccessToken","refreshToken","getRefreshToken","identityClaims","getIdentityClaims","idToken","getIdToken","logoutUrl","factory","providedIn"],"sourceRoot":"","sources":["/home/david/perso/home-api/apps/server-manager/front/app/core/auth.service.ts"],"sourcesContent":["/* eslint-disable brace-style */\n\nimport { Injectable } from '@angular/core';\nimport { Router } from '@angular/router';\nimport { OAuthErrorEvent, OAuthService } from 'angular-oauth2-oidc';\nimport { BehaviorSubject, combineLatest, Observable } from 'rxjs';\nimport { filter, map } from 'rxjs/operators';\n\n@Injectable({ providedIn: 'root' })\nexport class AuthService {\n\n  private isAuthenticatedSubject$ = new BehaviorSubject<boolean>(false);\n  public isAuthenticated$ = this.isAuthenticatedSubject$.asObservable();\n\n  private isDoneLoadingSubject$ = new BehaviorSubject<boolean>(false);\n  public isDoneLoading$ = this.isDoneLoadingSubject$.asObservable();\n\n  /**\n   * Publishes `true` if and only if (a) all the asynchronous initial\n   * login calls have completed or errorred, and (b) the user ended up\n   * being authenticated.\n   *\n   * In essence, it combines:\n   *\n   * - the latest known state of whether the user is authorized\n   * - whether the ajax calls for initial log in have all been done\n   */\n  public canActivateProtectedRoutes$: Observable<boolean> = combineLatest([\n    this.isAuthenticated$,\n    this.isDoneLoading$\n  ]).pipe(map(values => values.every(b => b)));\n\n  private navigateToLoginPage() {\n    // TODO: Remember current URL\n    this.router.navigateByUrl('/should-login');\n  }\n\n  constructor(\n    private oauthService: OAuthService,\n    private router: Router,\n  ) {\n    // Useful for debugging:\n    this.oauthService.events.subscribe(event => {\n      if (event instanceof OAuthErrorEvent) {\n        console.error('OAuthErrorEvent Object:', event);\n      } else {\n        console.warn('OAuthEvent Object:', event);\n      }\n    });\n\n    // This is tricky, as it might cause race conditions (where access_token is set in another\n    // tab before everything is said and done there.\n    // TODO: Improve this setup. See: https://github.com/jeroenheijmans/sample-angular-oauth2-oidc-with-auth-guards/issues/2\n    window.addEventListener('storage', (event) => {\n      // The `key` is `null` if the event was caused by `.clear()`\n      if (event.key !== 'access_token' && event.key !== null) {\n        return;\n      }\n\n      console.warn('Noticed changes to access_token (most likely from another tab), updating isAuthenticated');\n      this.isAuthenticatedSubject$.next(this.oauthService.hasValidAccessToken());\n\n      if (!this.oauthService.hasValidAccessToken()) {\n        this.navigateToLoginPage();\n      }\n    });\n\n    this.oauthService.events\n      .subscribe(_ => {\n        this.isAuthenticatedSubject$.next(this.oauthService.hasValidAccessToken());\n      });\n    this.isAuthenticatedSubject$.next(this.oauthService.hasValidAccessToken());\n\n    this.oauthService.events\n      .pipe(filter(e => ['token_received'].includes(e.type)))\n      .subscribe(e => this.oauthService.loadUserProfile());\n\n    this.oauthService.events\n      .pipe(filter(e => ['session_terminated', 'session_error'].includes(e.type)))\n      .subscribe(e => this.navigateToLoginPage());\n\n    // this.oauthService.setup();\n  }\n\n  public runInitialLoginSequence(): Promise<void> {\n    if (location.hash) {\n      console.log('Encountered hash fragment, plotting as table...');\n      console.table(location.hash.substr(1).split('&').map(kvp => kvp.split('=')));\n    }\n\n    // 0. LOAD CONFIG:\n    // First we have to check to see how the IdServer is\n    // currently configured:\n    return this.oauthService.loadDiscoveryDocument()\n    .then(() => {\n      this.oauthService.initCodeFlow();\n    })\n  }\n\n  public login(targetUrl?: string) {\n    // Note: before version 9.1.0 of the library you needed to\n    // call encodeURIComponent on the argument to the method.\n    this.oauthService.initLoginFlow(targetUrl || this.router.url);\n  }\n\n  public logout() { this.oauthService.logOut(); }\n  public refresh() { this.oauthService.silentRefresh(); }\n  public hasValidToken() { return this.oauthService.hasValidAccessToken(); }\n\n  // These normally won't be exposed from a service like this, but\n  // for debugging it makes sense.\n  public get accessToken() { return this.oauthService.getAccessToken(); }\n  public get refreshToken() { return this.oauthService.getRefreshToken(); }\n  public get identityClaims() { return this.oauthService.getIdentityClaims(); }\n  public get idToken() { return this.oauthService.getIdToken(); }\n  public get logoutUrl() { return this.oauthService.logoutUrl; }\n}"]},"metadata":{},"sourceType":"module","externalDependencies":[]}